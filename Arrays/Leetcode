class Main {
public static void main (String[] args){

}

	//73 Leetcode
    public void setZeroes(int[][] matrix) {
        boolean fr=false,fc=false;
        for(int i=0 ; i<matrix.length;i++){
            for(int j=0 ; j<matrix[i].length ; j++){
                if(matrix[i][j]==0){
                    if(i==0) fr=true;
                    if(j==0) fc=true;
                    matrix[0][j]=0;
                    matrix[i][0]=0;
                }
            }
        }
        for(int i=1 ; i<matrix.length;i++){
            for(int j=1 ; j<matrix[0].length;j++){
                if(matrix[i][0] == 0 || matrix[0][j] ==0){
                    matrix[i][j]=0;
                }
            }
        }
        if(fr){
            for(int j=0 ; j<matrix[0].length;j++){
                matrix[0][j]=0;
            }
        }
        if(fc){
            for(int i=0 ; i<matrix.length;i++){
                matrix[i][0]=0;
            }
        }
    }

	//128 Leetcode
    public int longestConsecutive(int[] nums) {
        Set<Integer> ans = new HashSet<Integer>();
        int count=0;
        for(int i : nums){
            ans.add(i);
        }
        for(int i: ans){
            if(!ans.contains(i-1)){
                int length=1;
                while(ans.contains(i+length)){
                    length++;
                }
                count = Math.max(count,length);
            }
        } 
        return count;   
    }

    //31 Leetcode 
    public void nextPermutation(int[] nums) {
        int i= nums.length -2;
        while(i>=0 && nums[i]>=nums[i+1]){
            i--;
        }
        if(i>=0){
            int j =nums.length -1;
            while(j>=0 && nums[j]<=nums[i]){
                j--;
            }
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    public static void swap(int[] nums, int i ,int j){
        int temp = nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

    public static void reverse(int[] nums , int start){
        int end = nums.length -1;
        while(start<end){
            swap(nums,start,end);
            start++;
            end--;
        }
    }

//169 Leetcode
public int majorityElement(int[] nums) {
        int n=nums.length;
        int ans=0;
        Map<Integer,Integer> frequency = new HashMap<>();
        for(int i=0 ; i<nums.length ; i++){
                frequency.put(nums[i],frequency.getOrDefault(nums[i],0)+1);
                if(frequency.get(nums[i])>(n/2)){
                    ans=nums[i];
                }
            }
            return ans;
        }

//75 sort colours
public void sortColors(int[] nums) {
        int low=0,mid=0,high=nums.length-1;
        while(mid<=high){
            if(nums[mid]==0){
                int temp = nums[mid];
                nums[mid]=nums[low];
                nums[low]=temp;
                low++;mid++;
            }
            else if(nums[mid]==1){
                mid++;
            }
            else{
                int temp=nums[mid];
                nums[mid]=nums[high];
                nums[high]=temp;
                high--;
            }
        }
    }

//1 Leetcode
public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> remainder = new HashMap<>();
        for(int i=0 ; i< nums.length ; i++){
            int rem = target-nums[i];
            if(remainder.containsKey(rem)){
                return new int[] {i,remainder.get(rem)};
            }
            remainder.put(nums[i],i);
        }
        return new int[] {};
    }

//268 Leetcode
public int missingNumber(int[] nums) {
        int xor=0;
        for(int i=0 ; i<nums.length ; i++){
            xor = xor^nums[i];
        }
        for(int j=1 ; j<= nums.length ; j++){
            xor = xor^j;
        }
        return xor;
    }

//485 Leetcode
public int findMaxConsecutiveOnes(int[] nums) {
    int max=0,count=0;
    for(int i=0 ; i<nums.length ; i++){
        if(nums[i]!=1){
            max = Math.max(max,count);
            count=0;
        }else{
        count++;
        }
    }
max=Math.max(max,count);
return max;
}

//136 Leetcode
public int singleNumber(int[] nums) {
    int xor=0;
    for(int i=0 ;i<nums.length;i++){
        xor=xor^nums[i];
	}
    return xor;
}

//1752 Leetcode
public boolean check(int[] nums) {
        int count=0;
        int n= nums.length;
        if(nums[n-1]>nums[0]){
                count++;
            }
        for(int i=0 ; i< nums.length-1 ; i++) {
			if(nums[i]>nums[i+1]){
                count++;
            }
            if(count>1){
                return false;
            }
		}
        return true;    
    }

//26 Leetcode
public int removeDuplicates(int[] nums) {
        int i=0,j=0;
        HashSet<Integer> duplicate= new HashSet<Integer>();        
        while(i<nums.length){
            if(!duplicate.contains(nums[i])){
                nums[j]=nums[i];
                j++;
                duplicate.add(nums[i]);
            }
            i++;
        }
        return duplicate.size();
    }

  //189 Leetcode
  public void rotate(int[] nums, int k) {
        k = k% nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public static void reverse(int[] nums , int left , int right){
        while(left<right){
            int temp = nums[left];
            nums[left]=nums[right];
            nums[right]=temp;
            left++;
            right--;
        }
    }

  //283 Leetcode
  public void moveZeroes(int[] nums) {
        int j=0;
        for(int i=0 ; i<nums.length ; i++){
            if(nums[i]!=0){
                int temp = nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
                j++;
            }
        }
    }
}
