class Main {
public static void main (String[] args){

}

	//1901 - Leetcode
    public int[] findPeakGrid(int[][] mat) {
        int m = mat.length, n = mat[0].length;
        int low = 0, high = n - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int maxRow = 0;
            for (int i = 0; i < m; i++) {
                if (mat[i][mid] > mat[maxRow][mid]) {
                    maxRow = i;
                }
            }
            
            boolean leftIsBigger = mid > 0 && mat[maxRow][mid - 1] > mat[maxRow][mid];
            boolean rightIsBigger = mid < n - 1 && mat[maxRow][mid + 1] > mat[maxRow][mid];
            
            if (!leftIsBigger && !rightIsBigger) {
                return new int[]{maxRow, mid};
            } else if (leftIsBigger) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return new int[]{-1, -1};
    }

	//240 - Leetcode
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) return false;
        
        int n = matrix.length;        // Number of rows
        int m = matrix[0].length;     // Number of columns
        
        // Start at the Top-Right corner
        int row = 0; 
        int col = m - 1;    
        
        while (row < n && col >= 0) {
            if (matrix[row][col] == target) {
                return true; // Found it
            } else if (matrix[row][col] < target) {
                // Current is too small, go down to find bigger numbers
                row++;
            } else {
                // Current is too big, go left to find smaller numbers
                col--;
            }
        }
        
        return false; // Out of bounds, target not found
    }

	//74 Leetcode
    public boolean searchMatrix(int[][] matrix, int target) {
        int top=0;
        int bot= matrix.length -1;

        while(top <= bot){
            int mid = top + (bot - top)/2;
            if(matrix[mid][0] < target && matrix[mid][matrix[mid].length - 1]> target){
                break;
            } else if(matrix[mid][0] > target){
                bot = mid -1;
            }else{
                top = mid + 1;
            }
        }
        int row = (top + bot) / 2;

        int left = 0;
        int right = matrix[row].length - 1;

        while (left <= right) {
            int mid = (left + right) / 2;

            if (matrix[row][mid] == target) {
                return true;
            } else if (matrix[row][mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }

        return false;        
    }

	//4 Leetcode
	public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int i = 0, j = 0, m1 = 0, m2 = 0;

        for (int count = 0; count <= (n + m) / 2; count++) {
            m2 = m1;
            if (i != n && j != m) {
                if (nums1[i] > nums2[j]) {
                    m1 = nums2[j++];
                } else {
                    m1 = nums1[i++];
                }
            } else if (i < n) {
                m1 = nums1[i++];
            } else {
                m1 = nums2[j++];
            }
        }

        // Check if the sum of n and m is odd.
        if ((n + m) % 2 == 1) {
            return (double) m1;
        } else {
            double ans = (double) m1 + (double) m2;
            return ans / 2.0;
        }

	//410 Leetcode
    public int splitArray(int[] nums, int k) {
       int n = nums.length;
        int min = Integer.MIN_VALUE;
        int max = 0;
        if(n < k){
            return 0;
        }
        for(int num : nums){
            min = Math.max(min, num);
            max += num;
        }

        int soln = 0;
        while(min <= max){
            int mid = min + (max-min)/2;
            if(canFit(nums, mid, k)){
                soln = mid;
                max = mid-1;
            }
            else{
                min = mid + 1;
            }
        }

        return soln;
    }

    public static boolean canFit(int[] nums,int perK,int k){
        int count = 1;
        int sum = 0;
        for(int num : nums){
            if((sum+num)>perK){
                count++;
                sum = num;
            }
            else{
                sum += num;
            }
        }
        return count <= k;
    }


	//1539 Leetcode
	public int findKthPositive(int[] arr, int k) {
        int start =0, end=arr.length-1;
        while(start<=end){
            int mid = start + (end - start)/2;

            if(arr[mid] - mid - 1 < k){
                start=mid+1;
            }
            else{
                end=mid-1;
            }
        }
        return start+k;
    }

	//1011 Leetcode
	public int shipWithinDays(int[] weights, int days) {
        int start = 0 , end = 0;
        for(int num : weights){
            start= Math.max(start , num);
            end += num;
        }
        while(start < end){
            int mid = start + (end - start)/2;
            int sum = 0;
            int day = 1;

            for(int num : weights){
                if(sum + num >mid){
                    day++;
                    sum=num;
                }
                else{
                    sum += num;
                }
            }
            if(day > days){
                start = mid+1;
            }
            else{
                end = mid;
            }
        }
        return start;
    }

	//1283 Leetcode
	public int smallestDivisor(int[] nums, int threshold) {
        int start=1, high=Integer.MAX_VALUE;
        int ans=0;
        for(int i: nums){
            high=Math.max(high,i);
        }

        while(start<=high){
            int mid = start + (high-start)/2;
            if(calculate(nums,mid,threshold)){
                ans=mid;
                high=mid-1;
            }
            else{
                start=mid+1;
            }
        }
        return ans;
    }

    public static boolean calculate(int[] nums,int mid,int threshold){
        int sum=0;
        for(int i=0;i<nums.length;i++){
            sum+= (nums[i]+mid-1)/mid;
        }

        return sum<=threshold;
    }

	//1482 Leetcode
	public int minDays(int[] bloomDay, int m, int k) {
        long val = (long) m * k ;
         int n =  bloomDay.length;
       // edge case 
       if(val > n ) return -1;

       int maxi = Integer.MIN_VALUE;
       int mini = Integer.MAX_VALUE;
        for(int i = 0 ; i < n ; i++){
        mini = Math.min(bloomDay[i],mini);

       maxi =  Math.max(bloomDay[i], maxi);
        }
        
        // NOW we do binary search 

        int low =  mini , high = maxi;

        while(low <= high){
            int mid = (low+high)/2;

            if(possible(bloomDay,mid,m,k)){
                high = mid - 1;
            }else{
                low = mid + 1;
            }
        }

        return low;
        
    }

    public static Boolean possible(int [] bloomDay , int day , int m , int k){
        int cnt = 0, noOfB = 0;
         int n = bloomDay.length;
        for(int i = 0 ; i< n ; i++){
        if(bloomDay[i] <= day){
            cnt++;
        }else{
            noOfB += (cnt/k);
            cnt = 0;
        }
        }

        noOfB += (cnt/k);
        return noOfB >= m ;
    }
    

	//875 Leetcode
    public boolean isPossible(int mid, int[] arr, int h){
    long hours = 0;
        int n = arr.length;
        for(int i=0;i<n;i++){
            hours += (arr[i] + mid - 1) / mid; 
        }
        if(hours>h) return false;
        return true;
    }
    public int minEatingSpeed(int[] arr, int h) {
        int n = arr.length;
        int lo = 1;
        int hi = Integer.MIN_VALUE;
        
        for(int i=0;i<n;i++){
            hi = Math.max(hi,arr[i]);
        }
        int ans = hi;
        while(lo<=hi){
            int mid = lo +(hi-lo)/2;
            if(isPossible(mid,arr,h)){
                ans = mid;
                hi = mid-1;
            }
            else{
                lo = mid+1;
            }
        }
        return ans;
    } 

	//162 Leetcode
    public int findPeakElement(int[] nums) {
            int start=0 , end = nums.length -1 ;
        while(start < end){
            int mid = start + (end - start)/2;
            if(nums[mid] > nums[mid+1]){
                end = mid;
            }
            else{
                start = mid+1;
            }
        }
        return start;
    }

	//540 Leetcode
    public int singleNonDuplicate(int[] nums) {
         int left = 0, right = nums.length-1;
        while(left < right){
            int mid = (left + right)/2;
            if( (mid % 2 == 0 && nums[mid] == nums[mid +1]) || (mid %2 == 1 && nums[mid] == nums[mid - 1]) )
                left = mid + 1;
            else
                right = mid;
        }
        return nums[left];
    }

	//153 Leetcode
    public int findMin(int[] nums) {
        int start=0,end=nums.length-1;
        while(start<end){
            int mid = start + (end - start)/2;
            if(nums[mid]<nums[end]){
                end=mid;
            }else{
                start=mid+1;
            }
        }
        return nums[start];
    }

	//81 Leetcode
    public boolean search(int[] nums, int target) {
        int start=0,end=nums.length-1;

        while(start<=end){
            int mid = start + (end - start)/2;

            if(nums[mid] == target){
                return true;
            }

            if (nums[mid] == nums[start]) {
                start++;
                continue;
            }
            if(nums[mid]>=nums[start]){
                if(nums[mid]>target && target >= nums[start]){
                    end = mid -1;
            }else{
                start = mid+1;
            }
            }
            else{
                if(nums[mid]<target && target<=nums[end]){
                    start=mid+1;
                }
                else{
                    end = mid-1;
                }
            }
        }
        return false;
    }

	//33 Leetcode
    public int search(int[] nums, int target) {
        int start=0 , end=nums.length-1;

        while(start<=end){
            int mid= start + (end-start)/2;
            if(nums[mid] == target){
                return mid;
            }
            if(nums[mid]>= nums[start]){
                if(nums[mid]>target && target>=nums[start]){
                    end = mid-1;
                }else{
                    start=mid+1;
                }
            }
            else{
                if(nums[mid]<target && target<=nums[end]){
                    start=mid+1;
                }else{
                    end=mid-1;
                }
            }
        }
        return -1;
    }

	//34 Leetcode
public int[] searchRange(int[] nums, int target) {
        int[] result = {-1,-1};
        int left = binarySearch(nums,target,true);
        int right = binarySearch(nums,target,false);

        result[0]=left;
        result[1]=right;
        return result;
    }

    public static int binarySearch(int[] nums, int target , boolean searchleft){
        int start = 0, end = nums.length -1,index=-1;

        while(start<=end){
            int mid = start + (end -start)/2;
            if(nums[mid]>target){
                end = mid-1;
            } 
            else if(nums[mid]<target){
                start = mid+1;
            } 
            else{
                index=mid;
                if(searchleft){
                    end=mid-1;
                }else{
                    start = mid+1;
                }
                
            }
        }
        return index;
    }

	//35 Leetcode
    public int searchInsert(int[] nums, int target) {
        int start =0;
        int end = nums.length-1;

        while(start<=end){
            int mid = start + (end-start)/2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) end = mid-1;
            else start = mid+1;
        }
        return start;
    }

	//704 Leetcode
    public int search(int[] nums, int target) {
    return help(nums,target,0,nums.length-1);
    }
    public static int help(int[] nums , int target , int low,int high){
        if(low>high){
            return -1;
            }
            int mid = low+(high-low)/2;

            if(nums[mid] == target){
                return mid;
            }
            else if(nums[mid]>target){
                return help(nums,target,low,mid-1);
            }
            else{
                return help(nums,target,mid+1,high);
            } 
    }
	
	//152 Leetcode
    public int maxProduct(int[] nums) {
        int max =nums[0];
        int l=1,r=1;
        for(int i=0 ; i<nums.length ; i++){
            l = l==0 ? 1:l;
            r = r==0 ? 1:r;
            l*=nums[i];
            r*=nums[nums.length-1-i];

            max = Math.max(max,Math.max(l,r));
        }
        return max;
    }

	//493 Leetcode
    public int reversePairs(int[] nums) {
        if(nums.length < 2){
            return 0;
        }
        int ans = dividePairs(nums,0,nums.length -1);
        System.gc();
        return ans;
    }

    private int dividePairs(int[] nums , int start , int end){
        if(start>=end){
            return 0;
        }
        int mid = start + (end-start)/2;
        int count = dividePairs(nums,start,mid) + dividePairs(nums, mid+1 , end);
        int i=start , j=mid+1;
        while(i<= mid && j<= end){
            if((long) nums[i] > 2L* (long)nums[j]){
                count+=mid-i+1;
                j++;
            }
            else{
                i++;
            }
        }
        int[] sorted = new int[end - start + 1]; 
        i = start;
        j = mid + 1;
        int k = 0;
        
        while (i <= mid && j <= end) {
            if (nums[i] <= nums[j]) {
                sorted[k++] = nums[i++];
            } else {
                sorted[k++] = nums[j++];
            }
        }

        while (i <= mid) {
            sorted[k++] = nums[i++];
        }
        while (j <= end) {
            sorted[k++] = nums[j++];
        }

        System.arraycopy(sorted, 0, nums, start, sorted.length);
        return count;
    }

	//88 Leetcode
    public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i=m-1;
    int j=n-1;
    int k=nums1.length-1;

    while(j>=0){
        if(i>=0 && nums1[i]>nums2[j]){
            nums1[k]=nums1[i];
            i--;k--;
        }
        else{
            nums1[k]=nums2[j];
            k--;j--;
        }
    }
    }

	//56 Leetocde
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));
        List<int[]> merged = new ArrayList<>();
        int[] prev = intervals[0];
        for(int i=1 ; i<intervals.length;i++){
            if(intervals[i][0]<= prev[1]){
                prev[1]= Math.max(prev[1],intervals[i][1]);
            }
            else{
                merged.add(prev);
                prev=intervals[i];
            }
        }
        merged.add(prev);
        return merged.toArray(new int[merged.size()][]);
    }

	//118 Leetcode
    public List<List<Integer>> generate(int numRows) {
        if(numRows==0){
            return new ArrayList<>();
        }
        if(numRows == 1){
            List<List<Integer>> ans = new ArrayList<>();
            ans.add(Arrays.asList(1));
            return ans;
        }
        List<List<Integer>> prevRow = generate(numRows - 1);
        List<Integer> newRow = new ArrayList<>();
        for(int i=0 ; i< numRows ; i++){
            newRow.add(1);
        }
        for(int i=1 ; i< numRows-1 ; i++){
            newRow.set(i , prevRow.get(numRows-2).get(i-1) + prevRow.get(numRows-2).get(i));
        }
        prevRow.add(newRow);
        return prevRow;
    }

	//18 Leetcode
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0 ; i< nums.length ;i++){
            if(i!=0 && nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1 ; j< nums.length ; j++){
                if(j>i+1 && nums[j]==nums[j-1]){
                    continue;
                }
                int k=j+1,l=nums.length-1;
                while(k<l){
                    long sum = (long)nums[i]+(long)nums[j]+(long)nums[k]+(long)nums[l];
                    if(sum>target){
                        l--;
                    }
                    else if (sum<target){
                        k++;
                    }
                    else if (sum == target){
                        ans.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));
                        k++;l--;
                        while(k<l && nums[k]==nums[k-1]) k++;
                        while(k<l && nums[l] == nums[l+1]) l--;
                    }
                }
            }
        }
        return ans;
    }

	//15 Leetcode
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0 ; i<nums.length ;i++){
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            int j=i+1,k=nums.length -1 ;
            while(j<k){
                int total = nums[i]+nums[j]+nums[k];
                if(total<0){
                    j++;
                }
                else if(total>0){
                    k--;
                }else{
                    ans.add(Arrays.asList(nums[i],nums[j],nums[k]));
                    j++;

                    while(nums[j]==nums[j-1] && j<k){
                        j++;
                    }
                }
            }
        }
        return ans;
    }

	//229 Leetcode
    public List<Integer> majorityElement(int[] nums) {
        HashMap<Integer,Integer> ans = new HashMap<>();
        List<Integer> result = new ArrayList<Integer>();

        for(int i=0 ; i< nums.length ; i++){
            if(ans.containsKey(nums[i])){
                ans.put(nums[i],ans.getOrDefault(nums[i],0)+1);
            }
            else{
            ans.put(nums[i],1);
            }
            if(ans.get(nums[i])>nums.length/3){
                if(!result.contains(nums[i]))
                result.add(nums[i]);
            }
        }
        return result;
    }
	
	//560 Leetcode
    public int subarraySum(int[] nums, int k) {
        int n=nums.length;
        int count=0,sum=0;
        HashMap<Integer,Integer> ans = new HashMap<Integer,Integer>();
        ans.put(0,1);
        for(int r=0 ; r< nums.length ; r++){
            sum=sum+nums[r];
            if(ans.containsKey(sum-k)){
                count+=ans.get(sum-k);
            }
            ans.put(sum,ans.getOrDefault(sum,0)+1);
        }
        return count;

    }

	//54 Spiral Matrix
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<Integer>();
        int top=0,bottom=matrix.length -1 ;
        int left=0,right=matrix[0].length -1;

        while(top<=bottom && left<= right){
            for(int j=left; j<= right ; j++){
                result.add(matrix[top][j]);
            }
            top++;

            for(int i=top ; i<=bottom ; i++){
                result.add(matrix[i][right]);
            }
            right--;

            if(top<=bottom){
                for(int j=right ; j>=left ; j--){
                    result.add(matrix[bottom][j]);
                }
                bottom--;
            }

            if(left<=right){
                for(int i=bottom ; i>=top ; i--){
                    result.add(matrix[i][left]);
                }
                left++;
            }
        }
        return result;
    }

	//48 Leetcode
    public void rotate(int[][] matrix) {
        int n= matrix.length;
       for(int i=0;i<matrix.length;i++){
        for(int j=i+1;j<matrix[i].length ; j++){
            int temp = matrix[i][j];
            matrix[i][j]=matrix[j][i];
            matrix[j][i]=temp;
        }
       } 

       for(int i=0 ; i< matrix.length;i++){
        int l=0,r=n-1;
        while(l<r){
            int temp = matrix[i][l];
            matrix[i][l]=matrix[i][r];
            matrix[i][r] = temp;
            l++;
            r--;
        }
       }
    }

	//73 Leetcode
    public void setZeroes(int[][] matrix) {
        boolean fr=false,fc=false;
        for(int i=0 ; i<matrix.length;i++){
            for(int j=0 ; j<matrix[i].length ; j++){
                if(matrix[i][j]==0){
                    if(i==0) fr=true;
                    if(j==0) fc=true;
                    matrix[0][j]=0;
                    matrix[i][0]=0;
                }
            }
        }
        for(int i=1 ; i<matrix.length;i++){
            for(int j=1 ; j<matrix[0].length;j++){
                if(matrix[i][0] == 0 || matrix[0][j] ==0){
                    matrix[i][j]=0;
                }
            }
        }
        if(fr){
            for(int j=0 ; j<matrix[0].length;j++){
                matrix[0][j]=0;
            }
        }
        if(fc){
            for(int i=0 ; i<matrix.length;i++){
                matrix[i][0]=0;
            }
        }
    }

	//128 Leetcode
    public int longestConsecutive(int[] nums) {
        Set<Integer> ans = new HashSet<Integer>();
        int count=0;
        for(int i : nums){
            ans.add(i);
        }
        for(int i: ans){
            if(!ans.contains(i-1)){
                int length=1;
                while(ans.contains(i+length)){
                    length++;
                }
                count = Math.max(count,length);
            }
        } 
        return count;   
    }

    //31 Leetcode 
    public void nextPermutation(int[] nums) {
        int i= nums.length -2;
        while(i>=0 && nums[i]>=nums[i+1]){
            i--;
        }
        if(i>=0){
            int j =nums.length -1;
            while(j>=0 && nums[j]<=nums[i]){
                j--;
            }
            swap(nums,i,j);
        }
        reverse(nums,i+1);
    }
    public static void swap(int[] nums, int i ,int j){
        int temp = nums[i];
        nums[i]=nums[j];
        nums[j]=temp;
    }

    public static void reverse(int[] nums , int start){
        int end = nums.length -1;
        while(start<end){
            swap(nums,start,end);
            start++;
            end--;
        }
    }

//169 Leetcode
public int majorityElement(int[] nums) {
        int n=nums.length;
        int ans=0;
        Map<Integer,Integer> frequency = new HashMap<>();
        for(int i=0 ; i<nums.length ; i++){
                frequency.put(nums[i],frequency.getOrDefault(nums[i],0)+1);
                if(frequency.get(nums[i])>(n/2)){
                    ans=nums[i];
                }
            }
            return ans;
        }

//75 sort colours
public void sortColors(int[] nums) {
        int low=0,mid=0,high=nums.length-1;
        while(mid<=high){
            if(nums[mid]==0){
                int temp = nums[mid];
                nums[mid]=nums[low];
                nums[low]=temp;
                low++;mid++;
            }
            else if(nums[mid]==1){
                mid++;
            }
            else{
                int temp=nums[mid];
                nums[mid]=nums[high];
                nums[high]=temp;
                high--;
            }
        }
    }

//1 Leetcode
public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> remainder = new HashMap<>();
        for(int i=0 ; i< nums.length ; i++){
            int rem = target-nums[i];
            if(remainder.containsKey(rem)){
                return new int[] {i,remainder.get(rem)};
            }
            remainder.put(nums[i],i);
        }
        return new int[] {};
    }

//268 Leetcode
public int missingNumber(int[] nums) {
        int xor=0;
        for(int i=0 ; i<nums.length ; i++){
            xor = xor^nums[i];
        }
        for(int j=1 ; j<= nums.length ; j++){
            xor = xor^j;
        }
        return xor;
    }

//485 Leetcode
public int findMaxConsecutiveOnes(int[] nums) {
    int max=0,count=0;
    for(int i=0 ; i<nums.length ; i++){
        if(nums[i]!=1){
            max = Math.max(max,count);
            count=0;
        }else{
        count++;
        }
    }
max=Math.max(max,count);
return max;
}

//136 Leetcode
public int singleNumber(int[] nums) {
    int xor=0;
    for(int i=0 ;i<nums.length;i++){
        xor=xor^nums[i];
	}
    return xor;
}

//1752 Leetcode
public boolean check(int[] nums) {
        int count=0;
        int n= nums.length;
        if(nums[n-1]>nums[0]){
                count++;
            }
        for(int i=0 ; i< nums.length-1 ; i++) {
			if(nums[i]>nums[i+1]){
                count++;
            }
            if(count>1){
                return false;
            }
		}
        return true;    
    }

//26 Leetcode
public int removeDuplicates(int[] nums) {
        int i=0,j=0;
        HashSet<Integer> duplicate= new HashSet<Integer>();        
        while(i<nums.length){
            if(!duplicate.contains(nums[i])){
                nums[j]=nums[i];
                j++;
                duplicate.add(nums[i]);
            }
            i++;
        }
        return duplicate.size();
    }

  //189 Leetcode
  public void rotate(int[] nums, int k) {
        k = k% nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public static void reverse(int[] nums , int left , int right){
        while(left<right){
            int temp = nums[left];
            nums[left]=nums[right];
            nums[right]=temp;
            left++;
            right--;
        }
    }

  //283 Leetcode
  public void moveZeroes(int[] nums) {
        int j=0;
        for(int i=0 ; i<nums.length ; i++){
            if(nums[i]!=0){
                int temp = nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
                j++;
            }
        }
    }
}
