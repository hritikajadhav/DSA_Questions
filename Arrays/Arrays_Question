public class Main { 

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {20,45,1,49,22,63};
		int[] arr1 = {1,20,22,45,49,63};
		int[] arr2 = {1,20};
		int[] arr3 = {1,3,4,5,2,1,5,6,3};
		removeDuplicateArray(arr3);
		//boolean y = isSorted(arr2);
		//int a = removeDuplicate(arr3);
		//System.out.println(a);
		//System.out.println(y);
		
	}

	//Maximum number of 1's in a row of matrix 05-12-25
	public static int rowWithMax1s(int[][] mat) {
		int m = mat.length;
		if(m==0) {
			return -1;
		}
		int n = mat[0].length;
		int row=0,col=n-1;
		int maxOnes=-1;
		
		while(row<m && col>=0) {
			if(mat[row][col] == 1) {
				maxOnes=row;
				col--;
			}else {
				row++;
			}
		}
		return maxOnes;       
    }

	//Painters job 04-12-25
	public static int findLargestMinDistance(int[] boards, int k) {
		int min= Integer.MIN_VALUE;
		int max =0;
		int ans=0;
		for(int i : boards) {
			min = Math.max(min , i);
			max+=i;
		}
		
		while(min<=max) {
			int mid = min + (max-min)/2;
			int a = countPainter(boards,mid);
			
			if(a>k) {
				min=mid+1;
			}
			else {
				ans=mid;
				max=mid -1;
			}
		}
		return ans;
	}
	
	public static int countPainter(int[] arr , int time) {
		int painter = 1;
		int boardpainted=0;
		
		for(int i : arr) {
			if(boardpainted+i <= time) {
				boardpainted+=i;	
			}else {
				painter++;
				boardpainted=i;
			}
		}
		return painter;
	}

	//Aggressive cows 03-12-25
    public boolean canPlace(int[] stalls, int cows, int d) {
        // Place first cow at first stall
        int count = 1;
        int lastPos = stalls[0];

        // Loop through stalls
        for (int i = 1; i < stalls.length; i++) {
            // If stall is at least d away from last placed cow
            if (stalls[i] - lastPos >= d) {
                // Place cow here
                count++;
                // Update last position
                lastPos = stalls[i];
            }
            // If all cows are placed successfully
            if (count >= cows) return true;
        }
        // Could not place all cows
        return false;
    }

    // Function to maximize minimum distance 03-12-25
    public int aggressiveCows(int[] stalls, int cows) {
        // Sort stalls
        Arrays.sort(stalls);

        // Define search space
        int low = 1;
        int high = stalls[stalls.length - 1] - stalls[0];
        int ans = 0;

        // Binary search
        while (low <= high) {
            // Find mid distance
            int mid = low + (high - low) / 2;

            // If placement possible
            if (canPlace(stalls, cows, mid)) {
                // Store answer
                ans = mid;
                // Try bigger distance
                low = mid + 1;
            }
            else {
                // Try smaller distance
                high = mid - 1;
            }
        }
        // Return result
        return ans;
    }

	//Nth root of a number 01-12-25
	public static int nthRoot(int m , int n) {
		int start=0,end=m;
		long ans=1;
		
		while(start<=end) {
			int mid = start + (end - start)/2;
			ans=1;
			for(int i=0 ; i<n; i++) {
				ans *= mid;
				if(ans>m) break;
			}
			if(ans == m) {
				return mid;
			}
			else if(ans<m) {
				start = mid+1;
			}
			else {
				end=mid - 1;
			}
		}
		return -1;
	}
	
	//Find a square root of a number 01-12-25
	public static int squareRootNumber(int a) {
		int start=0, end=a/2,ans=0;
		
		while(start<=end) {
			int mid = start + (end - start)/2;
			if(mid*mid<= a) {
				ans = (int)mid;
				start=(int)mid+1;
			}
			else {
				end=(int)mid-1;
			}
		}
		return ans;
	}

	//Find how many times an array is rotated 30-11-25
	public static int rotatedArray(int[] arr) {
		int start=0,end=arr.length -1;
		while(start<end) {
			int mid = start + (end - start)/2;
			
			if(arr[mid]>arr[end]) {
				start=mid+1;
			}
			else {
				end = mid;
			}
		}
		return start;
	}

	//count the occurrence of a number in a sorted array 29-11-25
	public static int occurrenceNumber(int[] nums , int target) {
		int result=-1;
		int left = binarySearch(nums,target,true);
		int right = binarySearch(nums,target,false);
		return right-left+1;
		
	}
	
	public static int binarySearch(int[] nums , int target , boolean searchleft) {
		int index=-1;
		int start = 0 , end=nums.length-1;
		
		while(start<=end) {
			int mid = start + (end-start)/2;
			if(nums[mid]> target) {
				 end= mid-1;
			}
			else if(nums[mid]< target) {
				start = mid+1;
			}
			else {
				index=mid;
				if(searchleft) {
					end=mid-1;
				}
				else {
					start=mid+1;
				}
			}
		}
		return index;
	}
	

	//Floor and ceiling of A number in an array (Floor,Ceiling) 29-11-25
	public static int[] floorCeiling(int[] arr , int k) {
		if(k>arr[arr.length-1]) {
			return new int[] {arr.length - 1, -1};
		}
		
		if(k<arr[0]) {
			return new int[] {-1, 0};
		}
		
		int start=0,end=arr.length-1;
		
		while(start<=end) {
			int mid = start+(end - start)/2;
			
			if(arr[mid]<k) {
				start = mid+1;
			}
			else if(arr[mid]>k) {
				end=mid-1;
			}
			else {
				return new int[] {mid,mid};
			}
		}
		
		return new int[] {end,start};
	}
	//28-11-25 Upper Bound
		public static int UpperBound(int[]arr , int k) {
			int low=0;
			int high= arr.length;
			int ans = arr.length;

			while(low<=high) {
				int mid = low + (high-low)/2;
				if(arr[mid]>k) {
					ans=mid;
					high=mid-1;
				}else {
					low=mid+1;
				}
				
			}
			return ans;
		}

	//28-11-25 Lower Bound
	public static int lowerBound(int[]arr , int k) {
		int low=0;
		int high= arr.length;
		int ans = arr.length;

		while(low<=high) {
			int mid = low + (high-low)/2;
			if(arr[mid]>=k) {
				ans=mid;
				high=mid-1;
			}else {
				low=mid+1;
			}
			
		}
		return ans;
	}

	//Missing number and duplicate number 27-11-25
	public static int[] duplicateMissing(int[] arr) {
		int correct =0;
		int missing=0;
		int i=0;
		while(i<arr.length) {
			correct = arr[i] - 1;
			if(arr[i] <= arr.length && arr[i] != arr[correct]) {
				int temp = arr[i];
				arr[i] = arr[correct];
				arr[correct]=temp;
				
			}
			else {
				i++;
			}
		}
		int duplicate=0;
        for (int index = 0; index < arr.length; index++) {
            if (arr[index] != index +1) {
                missing=index + 1;
                duplicate = arr[index];
                
            }
        }
        return new int[] {duplicate,missing};
	}

	//Count number of subarrays with xor equal to k target 26-11-25	
	public static int xorSubarray(int[] arr , int k) {
		Map<Integer , Integer> ans = new HashMap<>();
		ans.put(0, 1);
		int xor = 0;
		int target=0;
		int count=0;
		for(int i=0 ; i<arr.length ; i++) {
			xor = xor^arr[i];
			target=xor^k;
			if(ans.containsKey(target)) {
				count+=ans.get(target);
			}
			ans.put(xor, ans.getOrDefault(xor, 0)+1);
		}
		return count;
	}	

	//Length of the longest array with sum 0 26-11-25
    public static int maxLength(int[] arr ) {
    	HashMap<Integer , Integer> ans = new HashMap<>();
    	int sum =0;
    	int length=0;
    	for(int i=0 ; i< arr.length ; i++) {
    		sum=sum+arr[i];
    		if(sum == 0) {
    			length = i+1;
    		}
    		else if(ans.containsKey(sum)) {
    			length = Math.max(length, i-ans.get(sum));
    		}
    		else {
    			ans.put(sum, i);
    		}
    	}
    	return length;
    }

	//Leader in an array 23-11-25
	public static ArrayList<Integer> leaderArray(int[] arr) {
		ArrayList<Integer> ans = new ArrayList<>();
		ans.add(arr[arr.length-1]);
		for(int i=arr.length -1 ; i>1 ; i--) {
			if(arr[i]<arr[i-1]) {
				ans.add(0,arr[i-1]);
			}
		}
		
		for(int i : ans) {
			System.out.print(i);
		}
		return ans;
	}

//print max_subarray with max sum
public static void printSubArray(int[] arr){
		int start=0,end=0,max=0,sum=0;
		for(int i=0 ;i<arr.length;i++) {
			if(sum<0) {
				sum=0;
				start=i;
			}
			sum=sum+arr[i];
			if(sum>max) {
				max=sum;
				end=i;
			}
		}
		
		for(int i=start ; i<=end ; i++) {
			System.out.println(arr[i]);
		}
	}
	//max sub array with sum k (negative+positive)21-11-25
	public static int subarraySumNegative(int[] a , int k) {
		int n = a.length; 
        int maxLen = 0;   
        for (int i = 0; i < n; i++) {
            int sum = 0; 
            for (int j = i; j < n; j++) {
                sum += a[j]; 
                if (sum == k) {            
                    maxLen = Math.max(maxLen, j - i + 1);
                }
            }
        }

        return maxLen; 
	}
	
	//2 Sum 21-11-25
	public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> remainder = new HashMap<>();
        for(int i=0 ; i< nums.length ; i++){
            int rem = target-nums[i];
            if(remainder.containsKey(rem)){
                return new int[] {i,remainder.get(rem)};
            }
            remainder.put(nums[i],i);
        }
        return new int[] {};
    }
	
	//sort 0,1,2 21-11-25
	public void sortColors(int[] nums) {
        int low=0,mid=0,high=nums.length-1;
        while(mid<=high){
            if(nums[mid]==0){
                int temp = nums[mid];
                nums[mid]=nums[low];
                nums[low]=temp;
                low++;mid++;
            }
            else if(nums[mid]==1){
                mid++;
            }
            else{
                int temp=nums[mid];
                nums[mid]=nums[high];
                nums[high]=temp;
                high--;
            }
        }
    }
	//majority of a number 21-11-25
	public int majorityElement(int[] nums) {
        int n=nums.length;
        int ans=0;
        Map<Integer,Integer> frequency = new HashMap<>();
        for(int i=0 ; i<nums.length ; i++){
                frequency.put(nums[i],frequency.getOrDefault(nums[i],0)+1);
                if(frequency.get(nums[i])>(n/2)){
                    ans=nums[i];
                }
            }
            return ans;
        }
		//Longest sub-array having k sum(only positive) 21-10-25
	public static int subarraySum(int[] a , int k) {
		int sum=a[0],right=0,left=0,maxLen=0;
		int n = a.length;
		while (right < n) {
            while (left <= right && sum > k) {
                sum -= a[left];
                left++;
            }
            if (sum == k) {
                maxLen = Math.max(maxLen, right - left + 1);
            }
            right++;
            if (right < n) sum += a[right];
        }

        return maxLen;
	}
	//Union of 2 arrays 20-11-25
	public static void union(int[] arr1 , int[] arr2) {
		HashSet<Integer> union = new HashSet<Integer>();
		for(int i =0 ; i<arr1.length ; i++) {
			union.add(arr1[i]);
		}
		for(int i =0 ; i<arr2.length ; i++) {
			union.add(arr2[i]);
		}
		System.out.println(union);
		
	}
	
	//Linear Search
	public static boolean linearSearch(int[] arr , int target) {
		for(int i=0 ; i<arr.length; i++) {
			if(arr[i]==target) {
				return true;
			}
		}
		return false;
	}

	//1st and 2nd max element in an array.
	public static int maxInteger(int[] arr) {
		int max=0;
		int max1=0;
		for(int i : arr) {
			if(max<i) {
				max1=max;
				max=i;
			}
		}
		System.out.println(max);
		System.out.println(max1);
		return max;
	}

	//Array is sorted or not
	public static boolean isSorted(int[] arr) {
		for(int i=0 ; i< arr.length -1 ; i++) {
			if(arr[i]< arr[i+1]) {
				continue;
			}
			else {
				return false;
			}
		}
		return true;
	}

	//Number of unique elements in an array
	public static int removeDuplicate(int[] arr) {
		HashSet<Integer> duplicate = new HashSet<Integer>();
		for(int i : arr) {
			duplicate.add(i);
		}
		return duplicate.size();
	}

	}
